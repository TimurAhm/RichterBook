internal class Program
{
    private static void Main(string[] args)
    {
        SomeMethod();
    }

    public static void Swap(ref object a, ref object b)
    {
        Object t = b;
        b = a;
        a = t;
    }

    public static void SomeMethod()
    {
        String s1 = "J";
        String s2 = "R";

        //Swap(ref s1, ref s2);
        // сразу засунуть в аргументы string, хоть и принимаемыми явзяется object не получится
        // переменные передаваемые по ссылке, должны быть одного типа, объявленного в сигнатуре метода.

        // поэтому в этом случае, их нужно кастить
        Object o1 = s1, o2 = s2;
        Swap(ref o1, ref o2);

        s1 = (String) o1;
        s2 = (String) o2;

        Console.WriteLine(s1);
        Console.WriteLine(s2);
    }
}

// ref в этом случае, обеспечивает передачу ВНУТРИ МЕТОДА аргумента по ссылке (обычно это происходит по значению),
// что дает нам возможность менять значение переданного САМОГО аргумента, тк при передаче значением, они копировались
// в новую ячейку памяти, и позже сборщик делал свое дело

// ну out сделает тоже самое, но в отличие от ref, с ним можно использовать новые, не инициализированные переменные
// *в ref же обязательно, чтобы аргумент был уже инициализирован